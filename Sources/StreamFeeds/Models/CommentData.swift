//
// Copyright Â© 2025 Stream.io Inc. All rights reserved.
//

import Foundation
import StreamCore

/// A data model representing a comment in the Stream Feeds system.
///
/// This struct contains all the information about a comment, including its content,
/// metadata, reactions, replies, and user information. It supports threaded comments
/// with nested replies and real-time reaction tracking.
///
/// ## Usage
///
/// ```swift
/// // Access comment properties
/// let commentText = comment.text ?? ""
/// let author = comment.user
/// let reactionCount = comment.reactionCount
///
/// // Check if comment has replies
/// if comment.isThreaded {
///     let replies = comment.replies ?? []
///     // Display threaded comments
/// }
///
/// // Check user reactions
/// let userReactions = comment.latestReactions
/// let reactionGroups = comment.reactionGroups
/// ```
///
/// ## Features
///
/// - **Threaded Comments**: Supports nested comment replies
/// - **Reactions**: Tracks user reactions and reaction counts
/// - **Mentions**: Supports user mentions with metadata
/// - **Attachments**: Supports file and media attachments
/// - **Moderation**: Includes moderation and scoring data
/// - **Real-time Updates**: Designed for real-time state management
///
/// ## Thread Safety
///
/// This struct is thread-safe and conforms to `Sendable` for safe concurrent access.
public struct CommentData: Identifiable, Sendable {
    /// File attachments associated with the comment.
    ///
    /// This property contains any files, images, or other media attached to the comment.
    /// The attachments are typically used for rich media comments.
    public let attachments: [Attachment]?
    
    /// A confidence score indicating the quality or relevance of the comment.
    ///
    /// This score is typically generated by AI or moderation systems to indicate
    /// how confident the system is in the comment's quality or relevance.
    public let confidenceScore: Float
    
    /// A controversy score indicating the potential controversy level of the comment.
    ///
    /// This score helps identify comments that might be controversial or require
    /// additional moderation attention.
    public let controversyScore: Float?
    
    /// The date and time when the comment was created.
    public let createdAt: Date
    
    /// Custom data associated with the comment.
    ///
    /// This property allows for storing additional metadata or custom fields
    /// specific to your application's needs.
    public let custom: [String: RawJSON]?
    
    /// The date and time when the comment was deleted, if applicable.
    ///
    /// If the comment has been deleted, this property contains the deletion timestamp.
    /// If the comment is still active, this property is `nil`.
    public let deletedAt: Date?
    
    /// The number of downvotes received by the comment.
    public let downvoteCount: Int
    
    /// The unique identifier of the comment.
    public let id: String
    
    /// The most recent reactions added to the comment.
    ///
    /// This property contains the latest reactions from users, typically limited
    /// to the most recent ones to keep the data size manageable.
    public private(set) var latestReactions: [FeedsReactionData]
    
    /// Users mentioned in the comment.
    ///
    /// This property contains the list of users who were mentioned in the comment
    /// using @mentions or similar functionality.
    public let mentionedUsers: [UserData]
    
    /// Metadata about the comment's replies structure.
    ///
    /// This property contains information about the threading structure of replies,
    /// such as reply counts and pagination information.
    public let meta: RepliesMeta?
    
    /// The ID of the object this comment belongs to (e.g., activity ID).
    public let objectId: String
    
    /// The type of object this comment belongs to (e.g., "activity").
    public let objectType: String
    
    /// All the reactions from the current user.
    public private(set) var ownReactions: [FeedsReactionData]
    
    /// The ID of the parent comment, if this is a reply.
    ///
    /// If this comment is a reply to another comment, this property contains
    /// the ID of the parent comment. For top-level comments, this is `nil`.
    public let parentId: String?
    
    /// The total number of reactions on the comment.
    ///
    /// This property tracks the total count of all reactions across all types.
    public private(set) var reactionCount: Int
    
    /// Groups of reactions by type.
    ///
    /// This property organizes reactions by their type (e.g., "like", "love", "laugh")
    /// and provides counts and metadata for each reaction type.
    public private(set) var reactionGroups: [String: ReactionGroupData]
    
    /// The replies to this comment, if any.
    ///
    /// This property contains the nested replies to this comment, supporting
    /// threaded comment structures. For comments without replies, this is `nil`.
    public internal(set) var replies: [CommentData]?
    
    /// The number of replies to this comment.
    ///
    /// This property tracks the total count of replies, which may be different
    /// from the actual number of replies loaded in the `replies` property due
    /// to pagination or loading limits.
    public private(set) var replyCount: Int
    
    /// A score assigned to the comment (e.g., relevance, quality).
    ///
    /// This score is typically used for sorting or ranking comments based on
    /// various factors like relevance, quality, or engagement.
    public let score: Int
    
    /// The current status of the comment (e.g., "active", "deleted", "moderated").
    public let status: String
    
    /// The text content of the comment.
    ///
    /// This property contains the main text content of the comment. It may be
    /// `nil` for comments that only contain attachments or other media.
    public let text: String?
    
    /// The date and time when the comment was last updated.
    public let updatedAt: Date
    
    /// The number of upvotes received by the comment.
    public let upvoteCount: Int
    
    /// The user who created the comment.
    public let user: UserData
    
    /// Indicates whether this comment has threaded replies.
    ///
    /// This computed property checks if the comment has any replies loaded
    /// or if it has a reply count greater than zero.
    public var isThreaded: Bool {
        replies != nil
    }
}

// MARK: - Mutating the Data

extension CommentData {
    // MARK: - Comments
    
    mutating func addReaction(_ reaction: FeedsReactionData) {
        if reaction.user.id == user.id {
            ownReactions.append(reaction)
        }
        FeedsReactionData.updateByAdding(reaction: reaction, to: &latestReactions, reactionGroups: &reactionGroups)
        reactionCount = reactionGroups.values.reduce(0) { $0 + $1.count }
    }
    
    mutating func removeReaction(_ reaction: FeedsReactionData) {
        ownReactions.remove(byId: reaction.id)
        FeedsReactionData.updateByRemoving(reaction: reaction, from: &latestReactions, reactionGroups: &reactionGroups)
        reactionCount = reactionGroups.values.reduce(0) { $0 + $1.count }
    }
    
    // MARK: - Replies
    
    mutating func addReply(_ comment: CommentData) {
        var replies = replies ?? []
        replies.insert(byId: comment)
        self.replies = replies
        replyCount += 1
    }
    
    mutating func removeReply(_ comment: CommentData) {
        var replies = replies ?? []
        replies.remove(byId: comment.id)
        self.replies = replies
        replyCount = max(0, replyCount - 1)
    }
    
    mutating func replaceReply(_ comment: CommentData) {
        var replies = replies ?? []
        replies.replace(byId: comment)
        self.replies = replies
    }
}

// MARK: - Sorting

extension CommentData {
    static let defaultSorting: @Sendable (CommentData, CommentData) -> Bool = { $0.createdAt > $1.createdAt }
}

// MARK: - Model Conversions

extension CommentResponse {
    func toModel() -> CommentData {
        CommentData(
            attachments: attachments,
            confidenceScore: confidenceScore,
            controversyScore: controversyScore,
            createdAt: createdAt,
            custom: custom,
            deletedAt: deletedAt,
            downvoteCount: downvoteCount,
            id: id,
            latestReactions: latestReactions?.map { $0.toModel() } ?? [],
            mentionedUsers: mentionedUsers.map { $0.toModel() },
            meta: nil,
            objectId: objectId,
            objectType: objectType,
            ownReactions: ownReactions.map { $0.toModel() },
            parentId: parentId,
            reactionCount: reactionCount,
            reactionGroups: reactionGroups?.compactMapValues { $0?.toModel() } ?? [:],
            replies: nil,
            replyCount: replyCount,
            score: score,
            status: status,
            text: text,
            updatedAt: updatedAt,
            upvoteCount: upvoteCount,
            user: user.toModel()
        )
    }
}

extension ThreadedCommentResponse {
    /// Converts a threaded API response to a local comment data model.
    ///
    /// This method transforms the threaded API response model into the local `CommentData`
    /// model, including any nested replies.
    ///
    /// - Returns: A `CommentData` instance representing the comment with replies
    func toModel() -> CommentData {
        CommentData(
            attachments: attachments,
            confidenceScore: confidenceScore,
            controversyScore: controversyScore,
            createdAt: createdAt,
            custom: custom,
            deletedAt: deletedAt,
            downvoteCount: downvoteCount,
            id: id,
            latestReactions: latestReactions?.map { $0.toModel() } ?? [],
            mentionedUsers: mentionedUsers.map { $0.toModel() },
            meta: meta,
            objectId: objectId,
            objectType: objectType,
            ownReactions: ownReactions.map { $0.toModel() },
            parentId: parentId,
            reactionCount: reactionCount,
            reactionGroups: reactionGroups?.compactMapValues { $0?.toModel() } ?? [:],
            replies: replies?.map { $0.toModel() },
            replyCount: replyCount,
            score: score,
            status: status,
            text: text,
            updatedAt: updatedAt,
            upvoteCount: upvoteCount,
            user: user.toModel()
        )
    }
}
